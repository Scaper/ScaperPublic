[<AutoOpen>]
module Helpers

open System
open System.IO
open System.Collections.Generic
open MKLNET

//convenience math and conversion functions

///Integer of floor
let inline ifloor (v:float) = int (floor v)

///Integer of ceiling
let inline iceil (v:float) = int (ceil v)

//Fractional part
let inline frac (v:float) = v - floor v

//Cosine smooth - turns number between zero and 1 into a smooth cosine curve between 0 and 1 
let cosSmooth x = (cos ((x + 1.0)*Math.PI) + 1.0)/2.0

///Underlying value of enum (usually int)
let inline asVal enum = LanguagePrimitives.EnumToValue enum

///All values of enum type as array
let inline enumValues<'T when 'T :> Enum> () = Enum.GetValues(typeof<'T>) :?> 'T[]

///Maximum enum value
let inline enumMaxVal<'T when 'T :> Enum> () = Array.max (Enum.GetValuesAsUnderlyingType(typeof<'T>) :?> int[])

///1 if true; 0 if false
let inline asInt bool = if bool then 1 else 0

///Finds the element's first index in the array
let inline indexIn arr elem = arr |> Array.findIndex ((=) elem)

///Simple counter (useful for debugging)
type Counter(i) =
    let mutable c = i - 1
    member this.Next with get() = c <- c + 1; c
    new() = Counter(0)


///Normalizes an array to sum to 1
let normalizeSumTo1 (arr:float[]) : float[] =
    let sum = Span.sum arr
    arr |> Array.map (fun v -> v/sum)


///A type that keeps a map to cache values that are generated by a bound function. 
type Cacher<'k, 'v when 'k:comparison> () =
    let mutable map = Map<'k, 'v> Seq.empty

    ///When given only a function from key type to value type, produces a curried 
    ///function also from key type to value type, but now with caching.
    member this.memoize (func:'k -> 'v) (k:'k) : 'v = 
        match map.TryGetValue k with
        | true, v -> v
        | _ -> let v = func k
               map <- Map.add k v map
               v

    ///Empties the cache. Performs the given disposal function on all values in 
    ///the map before disposing.
    member this.clear(vDispose:'v->unit) = 
        Seq.iter vDispose map.Values
        map <- Map Seq.empty
   

///Wrapper for an enumerable whose elements will be disposed when this is disposed
type DisposableEnum<'t, 's when 's :> IEnumerable<'t> and 't :> IDisposable> (items:'s) =
    member this.Items = items
    interface IDisposable with
        member this.Dispose() = for i in items do i.Dispose()
    static member op_Implicit(d:DisposableEnum<'t, 's>) : 's = d.Items

///Create a disposable enumerable which will dispose each of its contents when it is disposed
let makeDisposable<'t, 's when 't :> IDisposable and 's :> IEnumerable<'t>> (items:'s) = 
    new DisposableEnum<_, _>(items)


    
///Transposes the provided array interpreted as a rows*cols matrix into the provided out array
let transpose (arr:float[]) (rows:int) (cols:int) (outArr:float[]) : float[] = 
    if rows * cols <> arr.Length then raise(ArgumentException("Array length must be product of provided row and column counts."))
    if arr.Length <> outArr.Length then raise(ArgumentException("Input and output arrays must have same length."))
    Blas.omatcopy(LayoutChar.RowMajor, TransChar.Yes, rows, cols, 1.0, arr, cols, outArr, rows)
    outArr


///Returns a new array which is the transpose of the provided array interpreted as a rows*cols matrix
let transposeNew (arr:float[]) (rows:int) (cols:int) : float[] = 
    transpose arr rows cols (Array.zeroCreate arr.Length)


///A TextWriter that writes to multiple outputs for logging
type MultiTextWriter ([<ParamArray>]writers:TextWriter[]) =
    inherit TextWriter() with
    override _.Write (value:char) =
        for w in writers do w.Write value
    override _.get_Encoding() = writers[0].get_Encoding()